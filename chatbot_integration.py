"""
EstateCore AI Chatbot Integration Module

Integrates the AI-powered tenant chatbot with the existing EstateCore application,\nincluding Flask app registration, database initialization, and service setup.\n\"\"\"\n\nimport os\nimport logging\nfrom flask import Flask\nfrom flask_socketio import SocketIO\nfrom flask_jwt_extended import JWTManager\n\n# Import chatbot components\nfrom chatbot_service.chatbot_api import ChatbotAPI, chatbot_bp\nfrom chatbot_service.websocket_handler import WebSocketHandler\nfrom chatbot_service.message_processor import MessageProcessor\nfrom chatbot_service.data_integration import DataIntegrationService\nfrom chatbot_service.escalation_manager import EscalationManager\n\n# Import AI modules\nfrom ai_modules.chatbot import (\n    NLPEngine, IntentClassifier, EntityExtractor,\n    ConversationManager, ResponseGenerator, SentimentAnalyzer, ContextManager\n)\n\n# Import models\nfrom models.chatbot import (\n    ChatbotConversation, ChatbotMessage, ChatbotEscalation, \n    ChatbotFeedback, ChatbotIntentTraining, ChatbotAnalytics, \n    ChatbotSettings, ChatbotQueries\n)\n\ndef init_chatbot_system(app: Flask, db, jwt: JWTManager) -> dict:\n    \"\"\"\n    Initialize the complete chatbot system with the Flask app\n    \n    Args:\n        app: Flask application instance\n        db: SQLAlchemy database instance\n        jwt: JWT manager instance\n        \n    Returns:\n        Dictionary with initialized chatbot components\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    logger.info(\"Initializing EstateCore AI Chatbot System...\")\n    \n    try:\n        # Initialize SocketIO for real-time communication\n        socketio = SocketIO(\n            app, \n            cors_allowed_origins=\"*\",\n            async_mode='threading',\n            logger=True,\n            engineio_logger=True\n        )\n        \n        # Initialize AI components\n        logger.info(\"Initializing AI components...\")\n        nlp_engine = NLPEngine()\n        intent_classifier = IntentClassifier()\n        entity_extractor = EntityExtractor(nlp_engine.nlp)\n        conversation_manager = ConversationManager()\n        response_generator = ResponseGenerator()\n        sentiment_analyzer = SentimentAnalyzer()\n        context_manager = ContextManager()\n        \n        # Initialize services\n        logger.info(\"Initializing chatbot services...\")\n        message_processor = MessageProcessor(\n            nlp_engine=nlp_engine,\n            intent_classifier=intent_classifier,\n            entity_extractor=entity_extractor,\n            sentiment_analyzer=sentiment_analyzer\n        )\n        \n        data_integration = DataIntegrationService()\n        escalation_manager = EscalationManager()\n        \n        # Set up dependencies\n        message_processor.set_dependencies(\n            response_generator=response_generator,\n            conversation_manager=conversation_manager,\n            context_manager=context_manager,\n            data_integration=data_integration\n        )\n        \n        # Initialize main chatbot API\n        chatbot_api = ChatbotAPI()\n        chatbot_api.message_processor = message_processor\n        chatbot_api.data_integration = data_integration\n        chatbot_api.escalation_manager = escalation_manager\n        chatbot_api.init_app(app)\n        \n        # Initialize WebSocket handler\n        websocket_handler = WebSocketHandler(socketio, message_processor)\n        \n        # Register additional routes\n        register_chatbot_routes(app, db)\n        \n        # Initialize database tables\n        create_chatbot_tables(app, db)\n        \n        # Load default settings\n        load_default_chatbot_settings(db)\n        \n        # Train models with default data\n        if app.config.get('CHATBOT_AUTO_TRAIN', True):\n            train_default_models(intent_classifier, db)\n        \n        logger.info(\"Chatbot system initialized successfully\")\n        \n        return {\n            'socketio': socketio,\n            'chatbot_api': chatbot_api,\n            'websocket_handler': websocket_handler,\n            'message_processor': message_processor,\n            'data_integration': data_integration,\n            'escalation_manager': escalation_manager,\n            'ai_components': {\n                'nlp_engine': nlp_engine,\n                'intent_classifier': intent_classifier,\n                'entity_extractor': entity_extractor,\n                'conversation_manager': conversation_manager,\n                'response_generator': response_generator,\n                'sentiment_analyzer': sentiment_analyzer,\n                'context_manager': context_manager\n            }\n        }\n        \n    except Exception as e:\n        logger.error(f\"Failed to initialize chatbot system: {e}\")\n        raise\n\ndef register_chatbot_routes(app: Flask, db):\n    \"\"\"\n    Register additional chatbot routes\n    \"\"\"\n    \n    @app.route('/api/chatbot/upload', methods=['POST'])\n    def upload_chatbot_file():\n        \"\"\"Handle file uploads for chatbot\"\"\"\n        from flask import request, jsonify\n        from flask_jwt_extended import jwt_required, get_jwt_identity\n        \n        try:\n            if 'file' not in request.files:\n                return jsonify({'success': False, 'error': 'No file provided'}), 400\n            \n            file = request.files['file']\n            conversation_id = request.form.get('conversation_id')\n            \n            if not file or not conversation_id:\n                return jsonify({'success': False, 'error': 'File and conversation ID required'}), 400\n            \n            # Save file (implement your file storage logic)\n            # For now, return placeholder\n            file_url = f'/uploads/chatbot/{conversation_id}/{file.filename}'\n            \n            return jsonify({\n                'success': True,\n                'file_url': file_url,\n                'file_name': file.filename,\n                'file_type': file.content_type,\n                'file_size': len(file.read())\n            })\n            \n        except Exception as e:\n            return jsonify({'success': False, 'error': str(e)}), 500\n    \n    @app.route('/api/escalations/queue', methods=['GET'])\n    def get_escalation_queue():\n        \"\"\"Get escalation queue\"\"\"\n        from flask import jsonify\n        from flask_jwt_extended import jwt_required\n        \n        try:\n            escalations = ChatbotQueries.get_pending_escalations()\n            return jsonify({\n                'success': True,\n                'escalations': [esc.to_dict() for esc in escalations]\n            })\n        except Exception as e:\n            return jsonify({'success': False, 'error': str(e)}), 500\n    \n    @app.route('/api/escalations/agents', methods=['GET'])\n    def get_escalation_agents():\n        \"\"\"Get available agents\"\"\"\n        from flask import jsonify\n        from flask_jwt_extended import jwt_required\n        \n        try:\n            # This would query your User model for agents\n            # For now, return placeholder data\n            agents = [\n                {\n                    'agent_id': 'agent_001',\n                    'name': 'Sarah Johnson',\n                    'department': 'customer_service',\n                    'availability_status': 'available',\n                    'current_cases': 2,\n                    'max_concurrent_cases': 5\n                }\n            ]\n            return jsonify({\n                'success': True,\n                'agents': agents\n            })\n        except Exception as e:\n            return jsonify({'success': False, 'error': str(e)}), 500\n\ndef create_chatbot_tables(app: Flask, db):\n    \"\"\"\n    Create chatbot database tables\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    \n    with app.app_context():\n        try:\n            # Create all chatbot tables\n            db.create_all()\n            logger.info(\"Chatbot database tables created successfully\")\n        except Exception as e:\n            logger.error(f\"Error creating chatbot tables: {e}\")\n            raise\n\ndef load_default_chatbot_settings(db):\n    \"\"\"\n    Load default chatbot configuration settings\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    \n    default_settings = {\n        'chatbot_enabled': True,\n        'chatbot_name': 'EstateCore Assistant',\n        'greeting_message': 'Hello! I\\'m here to help you with any questions about your property. How can I assist you today?',\n        'escalation_confidence_threshold': 0.6,\n        'max_conversation_age_hours': 24,\n        'auto_escalation_enabled': True,\n        'sentiment_escalation_threshold': -0.6,\n        'supported_languages': ['en', 'es', 'fr'],\n        'max_file_upload_size_mb': 10,\n        'allowed_file_types': ['image/*', 'video/*', '.pdf', '.txt', '.doc', '.docx'],\n        'response_timeout_seconds': 30,\n        'typing_indicator_timeout_ms': 3000,\n        'analytics_retention_days': 90\n    }\n    \n    try:\n        for key, value in default_settings.items():\n            existing = ChatbotQueries.get_setting(key)\n            if existing is None:\n                ChatbotQueries.update_setting(key, value, f\"Default {key} setting\")\n        \n        logger.info(\"Default chatbot settings loaded\")\n        \n    except Exception as e:\n        logger.error(f\"Error loading default settings: {e}\")\n\ndef train_default_models(intent_classifier, db):\n    \"\"\"\n    Train AI models with default data\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    \n    try:\n        # Check if we have existing training data\n        existing_data = db.session.query(ChatbotIntentTraining).count()\n        \n        if existing_data == 0:\n            logger.info(\"No existing training data found, creating default training set...\")\n            create_default_training_data(db)\n        \n        # Train the intent classifier\n        logger.info(\"Training intent classifier...\")\n        training_data = db.session.query(ChatbotIntentTraining).filter(\n            ChatbotIntentTraining.verified == True\n        ).all()\n        \n        if training_data:\n            training_pairs = [(item.text, item.intent) for item in training_data]\n            metrics = intent_classifier.train(training_pairs)\n            logger.info(f\"Intent classifier trained with accuracy: {metrics.get('accuracy', 0):.3f}\")\n        else:\n            # Use built-in training data\n            metrics = intent_classifier.train()\n            logger.info(f\"Intent classifier trained with default data, accuracy: {metrics.get('accuracy', 0):.3f}\")\n        \n    except Exception as e:\n        logger.error(f\"Error training models: {e}\")\n\ndef create_default_training_data(db):\n    \"\"\"\n    Create default training data for intent classification\n    \"\"\"\n    default_training_data = [\n        # Rent payment examples\n        (\"when is my rent due\", \"rent_payment\"),\n        (\"how do i pay rent\", \"rent_payment\"),\n        (\"what payment methods do you accept\", \"rent_payment\"),\n        (\"i want to pay my rent online\", \"rent_payment\"),\n        (\"my rent payment failed\", \"rent_payment\"),\n        \n        # Maintenance examples\n        (\"my air conditioning is broken\", \"maintenance_request\"),\n        (\"there is a leak in my bathroom\", \"maintenance_request\"),\n        (\"the elevator is not working\", \"maintenance_request\"),\n        (\"i need maintenance in my unit\", \"maintenance_request\"),\n        (\"can someone fix my dishwasher\", \"maintenance_request\"),\n        \n        # Lease inquiries\n        (\"when does my lease expire\", \"lease_inquiry\"),\n        (\"can i renew my lease\", \"lease_inquiry\"),\n        (\"where is my lease document\", \"lease_inquiry\"),\n        (\"what are the lease terms\", \"lease_inquiry\"),\n        (\"i want to break my lease\", \"lease_inquiry\"),\n        \n        # Amenities\n        (\"what amenities are available\", \"amenities_info\"),\n        (\"when is the pool open\", \"amenities_info\"),\n        (\"how do i access the gym\", \"amenities_info\"),\n        (\"where is the laundry room\", \"amenities_info\"),\n        (\"what are the parking rules\", \"amenities_info\"),\n        \n        # Contact info\n        (\"what are your office hours\", \"contact_info\"),\n        (\"how do i contact the office\", \"contact_info\"),\n        (\"who is my property manager\", \"contact_info\"),\n        (\"what is the emergency number\", \"contact_info\"),\n        (\"where is the leasing office\", \"contact_info\"),\n        \n        # Account balance\n        (\"what is my account balance\", \"account_balance\"),\n        (\"what charges do i have\", \"account_balance\"),\n        (\"why was i charged a fee\", \"account_balance\"),\n        (\"show me my payment history\", \"account_balance\"),\n        (\"what do i owe\", \"account_balance\"),\n        \n        # General\n        (\"hello\", \"general_inquiry\"),\n        (\"hi there\", \"general_inquiry\"),\n        (\"good morning\", \"general_inquiry\"),\n        (\"can you help me\", \"general_inquiry\"),\n        (\"thank you\", \"general_inquiry\"),\n        \n        # Emergency\n        (\"this is an emergency\", \"emergency\"),\n        (\"water is flooding my unit\", \"emergency\"),\n        (\"there is a fire\", \"emergency\"),\n        (\"gas leak in my apartment\", \"emergency\"),\n        (\"someone is locked out\", \"emergency\"),\n        \n        # Complaints\n        (\"i want to file a complaint\", \"complaint\"),\n        (\"my neighbors are too loud\", \"complaint\"),\n        (\"the service is poor\", \"complaint\"),\n        (\"i am not satisfied\", \"complaint\"),\n        (\"this is unacceptable\", \"complaint\")\n    ]\n    \n    try:\n        for text, intent in default_training_data:\n            training_item = ChatbotIntentTraining(\n                text=text,\n                intent=intent,\n                source='default',\n                verified=True,\n                language='en'\n            )\n            db.session.add(training_item)\n        \n        db.session.commit()\n        logging.getLogger(__name__).info(f\"Created {len(default_training_data)} default training examples\")\n        \n    except Exception as e:\n        db.session.rollback()\n        raise\n\ndef get_chatbot_health_status(chatbot_components: dict) -> dict:\n    \"\"\"\n    Get health status of all chatbot components\n    \"\"\"\n    try:\n        health_status = {\n            'overall_status': 'healthy',\n            'timestamp': datetime.now().isoformat(),\n            'components': {}\n        }\n        \n        # Check AI components\n        ai_components = chatbot_components.get('ai_components', {})\n        for component_name, component in ai_components.items():\n            try:\n                # Basic health check - component exists and has expected attributes\n                if hasattr(component, '__class__'):\n                    health_status['components'][component_name] = 'healthy'\n                else:\n                    health_status['components'][component_name] = 'unhealthy'\n            except Exception:\n                health_status['components'][component_name] = 'unhealthy'\n                health_status['overall_status'] = 'degraded'\n        \n        # Check services\n        services = ['chatbot_api', 'message_processor', 'data_integration', 'escalation_manager']\n        for service_name in services:\n            service = chatbot_components.get(service_name)\n            if service:\n                health_status['components'][service_name] = 'healthy'\n            else:\n                health_status['components'][service_name] = 'unhealthy'\n                health_status['overall_status'] = 'degraded'\n        \n        # Check WebSocket\n        socketio = chatbot_components.get('socketio')\n        if socketio:\n            health_status['components']['websocket'] = 'healthy'\n        else:\n            health_status['components']['websocket'] = 'unhealthy'\n            health_status['overall_status'] = 'degraded'\n        \n        return health_status\n        \n    except Exception as e:\n        return {\n            'overall_status': 'unhealthy',\n            'error': str(e),\n            'timestamp': datetime.now().isoformat()\n        }\n\ndef cleanup_chatbot_data(db, days_to_keep: int = 90):\n    \"\"\"\n    Cleanup old chatbot data based on retention policy\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    \n    try:\n        cutoff_date = datetime.now() - timedelta(days=days_to_keep)\n        \n        # Delete old resolved conversations and their messages\n        old_conversations = db.session.query(ChatbotConversation).filter(\n            ChatbotConversation.ended_at < cutoff_date,\n            ChatbotConversation.status.in_(['resolved', 'abandoned'])\n        ).all()\n        \n        deleted_count = 0\n        for conversation in old_conversations:\n            # Messages will be deleted by cascade\n            db.session.delete(conversation)\n            deleted_count += 1\n        \n        # Delete old analytics data\n        old_analytics = db.session.query(ChatbotAnalytics).filter(\n            ChatbotAnalytics.date < cutoff_date\n        ).all()\n        \n        for analytics in old_analytics:\n            db.session.delete(analytics)\n        \n        db.session.commit()\n        \n        logger.info(f\"Cleaned up {deleted_count} old conversations and {len(old_analytics)} analytics records\")\n        \n    except Exception as e:\n        db.session.rollback()\n        logger.error(f\"Error during chatbot data cleanup: {e}\")\n        raise"